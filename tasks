;;- create strings for errors int the .rodata
;;- create a constant to save 5 (maximum size of stack)
;; - create a counter that will track on the stack size
;; - create a variable for debug mode
;; - convert each 2 bytes from the input to BCD
;; - create a label 'stack'
		initialize the first 4 bytes (the address that points to the first argument in the stack) with null (0)
;; - every prompt, clean the input buffer so that there won't be any reminders on it from the last promt
;; - handle wierd inputs such as:
	;; 001 (zeros in the begining)- remove all leading zeros
	;; 0- create a single link of [0,NULL]
	;; 0000- remove all leading zeros and create a single link of [0, NULL]
	;; empty string input
;; - create a loop in my_calc which waits for input, do something and them go back in a loop to get an input again (use fgets). this prints ">>calc: "

;; - set debug mode to 1 when executing with "-d"
;; - handle debug modes
;; - every push to the stack we locate the new argument at [stack + 4*stack_pointer]
;; - create a label that loops for getting two numbers (12 for example) and create a link from then and concatenate the link to the adequate list by:
	check if there is enough space in the stack. if not, send an error.
	else:
	use mallok to make space on the heap for the link (5 byets)
	store somewhere the address of the link that is now in the heap
	the new link will point on the link that the list points on (the address on the stack)
	the list will point on the new link (which we have stored its address beforehand)
;; - imlplement feature p (prints ">>" instaed of ">>calc")

- imlplement feature d 
- free mempry of all links
- write tests
- remove label func_format
- remove label print_for_myself
- remove label fail_exit
- remove label debug_print_format


;----
call print_for_myself
;----


;////////////////
mov ebx, dword [stack_counter]              ; save counter inside ebx
push dword [stack + 4*ebx]
push format_int
call printf
add esp, 8
;////////////////





loop_lists_addition:
        mov dword [ebp-16], 0       ;initialize our cflag inticator

        cmp esi, 0
        je esi_link_got_to_end
        cmp edi, 0
        je edi_link_got_to_end
        cmp dword [ebp-4], 0
        je esi_link_got_to_one_before_end
        cmp dword [ebp-8], 0
        je edi_link_got_to_one_before_end

        ;add the two NEXT value in order to invoke the cflag
            mov ecx, dword [ebp-4]
            mov cl, byte [ecx]
            mov edx, dword [ebp-8]
            mov dl, byte [edx]
            jmp cont_1
            
        esi_link_got_to_end:
            mov cl, 0
            cmp edi, 0
            je return_add
            cmp dword [ebp-8], 0
            je edi_link_got_to_one_before_end
            mov ebx, dword [ebp-8] 
            mov dl, byte [ebx]
            jmp cont_1

        edi_link_got_to_end:
            mov dl, 0
            cmp esi, 0
            je return_add
            cmp dword [ebp-4], 0
            je esi_link_got_to_one_before_end
            mov ebx, dword [ebp-4] 
            mov cl, byte [ebx]
            jmp cont_1

        esi_link_got_to_one_before_end:
            mov cl, 0
            cmp dword [ebp-8], 0
            je put_in_dl_curr_link_data
            mov ebx, dword [ebp-8] 
            mov dl, byte [ebx]
            jmp cont_1

        edi_link_got_to_one_before_end:
            mov dl, 0
            cmp dword [ebp-4], 0
            je put_in_cl_curr_link_data
            mov ebx, dword [ebp-4]
            mov cl, byte [ebx]
            jmp cont_1

        put_in_dl_curr_link_data:
            cmp edi, 0
            je cont_1
            mov dl, byte [edi]
            jmp cont_1

        put_in_cl_curr_link_data:
            cmp esi, 0
            je cont_1
            mov cl, byte [esi]
            jmp cont_1

        put_zero_in_dl:
            mov dl, 0
            jmp cont_1

        put_zero_in_cl:
            mov cl, 0
            jmp cont_1

        cont_1:

        mov eax, 0

        cmp esi, 0
        je cont_2
        mov al, byte [esi]          ;assign the value of the curr link inlist 1 in al
        
        cmp edi, 0
        je cont_3
        
        cont_2:
            add al, byte [edi]          ;add the value of the curr link in list 2 to al
        
        cont_3:
        
        add cl, dl
        jnb do_daa
                add al, 1                      ;add the cf from the addition of the next links


        do_daa:
            daa                         ;adjust the above result to BCD and save the result in al
        
        jnb cont_add_loop
            mov dword [ebp-16], 1


            
        cont_add_loop:
            ;create a new link
                mov ebx, 0                  ;initialize ebx with 0
                mov bl, al                 ;save the value of the result from all above in bl (becasue malloc is going to change the value of eax)

                push ebx                    ;backup ebx because it might change during malloc
                push edi                    ;backup edi because it might change during malloc
                push esi                    ;backup esi because it might change during malloc

                push 5                      ;push amount of bytes malloc should allocate (1 for data and 4 for address)
                call malloc                 ;return value is saved in reg eax (the address of the new memory space in heap)!
                test eax, eax
                jz   fail_exit
                add esp,4                   ;undo push for malloc

                pop esi                     ;restore esi to what it was before calling malloc
                pop edi                     ;restore edi to what it was before calling malloc
                pop ebx                     ;restore ebx to what it was before calling malloc

            ;initialize the new link
                mov byte [eax], bl
                mov byte [eax+1], 0

            ;add the new link to the result link
                push edi                    ;backup edi cbecause it might change during add_to_list
                push esi                    ;backup esi cbecause it might change during add_to_list

                mov ecx, ebp
                sub ecx, 12
                push ecx                 ;push the LIST to add to which is located inside the x86 stack
                push eax                    ;push thr LINK to add
                call add_to_list
                add esp, 8                  ;undo pushes for add_to_list
                
                pop esi                     ;restore esi to what it was before calling add_to_list
                pop edi                     ;restore edi to what it was before calling add_to_list



            mov esi, dword [ebp-4]          ;advance the curr link of list 1 by 1
            mov edi, dword [ebp-8]          ;advance the curr link of list 2 by 1
        

            ;check if esi got to the end of list 1
                cmp esi, 0
                ;je loop_lists_addition
                je cont_a
                mov ecx, dword [esi+1]
                mov dword [ebp-4], ecx

                cont_a:
            ;check if edi got to the end of list 2
                cmp edi, 0
                je cont_b
                mov edx, dword [edi+1]
                mov dword [ebp-8], edx

            cont_b:
                cmp dword [ebp-16], 0               ;check if our cflag is NOT 0. if then go add anothr link after checking if we are in the last links
                jne cf_add_another_link

        jmp loop_lists_addition

        cf_add_another_link:
        
        ;if on the last two links the cflag was up- we need to create a new link with 1
            cmp esi, 0
            jne loop_lists_addition
            cmp edi, 0
            jne loop_lists_addition


            ;create a new link
                push ebx                    ;backup ebx because it might change during malloc
                push edi                    ;backup edi because it might change during malloc
                push esi                    ;backup esi because it might change during malloc

                push 5                      ;push amount of bytes malloc should allocate (1 for data and 4 for address)
                call malloc                 ;return value is saved in reg eax (the address of the new memory space in heap)!
                test eax, eax
                jz   fail_exit
                add esp,4                   ;undo push for malloc

                pop esi                     ;restore esi to what it was before calling malloc
                pop edi                     ;restore edi to what it was before calling malloc
                pop ebx                     ;restore ebx to what it was before calling malloc

            ;initialize the new link with data=1, next=NULL
                mov byte [eax], 1
                mov byte [eax+1], 0

            ;add the new link to the result link
                push edi                    ;backup edi cbecause it might change during add_to_list
                push esi                    ;backup esi cbecause it might change during add_to_list

                mov ecx, ebp
                sub ecx, 12
                push ecx                 ;push the LIST to add to which is located inside the x86 stack
                push eax                    ;push thr LINK to add
                call add_to_list
                add esp, 8                  ;undo pushes for add_to_list
                
                pop esi                     ;restore esi to what it was before calling add_to_list
                pop edi                     ;restore edi to what it was before calling add_to_list

            mov esi, dword [ebp-4]
            mov edi, dword [ebp-8]

            ;check if esi got to the end of list 1
                cmp esi, 0
                je loop_lists_addition

            ;check if edi got to the end of list 2
                cmp edi, 0
                je loop_lists_addition

            ;else
                mov ecx, dword [esi+1]
                mov dword [ebp-4], ecx

                mov edx, dword [edi+1]
                mov dword [ebp-8], edx


            jmp loop_lists_addition